<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
        <meta name="yandex-verification" content="147f9d9fe95452a9" />
        <title>NFSql - Need for Speedy SQL</title>
        <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
        <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
    </head>
    <body>

    <nav class="navbar navbar-expand-md navbar-dark bg-danger">
        <p class="text-danger">
            <a class="navbar-brand" href="#"><i class="fas fa-tachometer-alt"></i> NFSQL </a>
        </p>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>
    </nav>
<!--
        <nav class="navbar navbar-dark bd-navbar navbar-light sticky-top navbar-expand-md">
            <a class="navbar-brand" href="#">Navbar</a>
        </nav>
-->
        <div class="container" style="padding-top:50px;">
            <h1>
                NFSql
            </h1>
            <p class="lead text-muted">
                Need for Speedy SQL
            </p>
            <p>
                We help companies to speed up SQL database.
                NFSQL analyser parses your queries, checks your database structure and generates
                report that helps you to make your databases faster.
            </p>
            <form>
                <row>
                    <textarea rows="5" class="col-12" placeholder="Type your SQL query..."></textarea>
                </row>
                <row>
                    <p>
                        <button class="btn btn-info">Optimize</button>
                    </p>
                </row>
            </form>
            <p>
                NFSQL Optimizer includes different approaches for optimizing SQL queries. Here some of them:
            </p>
            <h3>
                Index for foreign keys
            </h3>
                    <p>
                        Create index for field if it's used in join.
                        It's one of the simplest way to optimize your queries but
                        sometimes it's too difficult to check if all indexes are created.
                        So it's usual when required indexes are missed.
                        <pre><code>
<b>SELECT</b> p.id, p.first_name, p.last_name, c.name <b>AS</b> company_name
<b>FROM</b> person p
  <b>JOIN</b> company c <b>on</b> <span class="text-danger">p.company_id</span> = c.id
                        </code></pre>
                        <p class="text-danger">Check if index for field person.company_id is created</p>
                    </p>

            <h3>
                Kick off of correlated subquery
            </h3>
                    <p>
                        Correlated query is a subquery which uses fields from super query as params.
                        So it can be executed many times (at least 1 query execution per one result row).
                    </p>
                        <pre><code>
<b>SELECT</b> p.id, p.first_name, p.last_name,
              (
                 <b>SELECT</b> c.name
                 <b>FROM</b> company c <b>where</b> c.id = <span class="text-danger">p.company_id</span>
              ) <b>AS</b> company_name
<b>FROM</b> person p
                        </code></pre>
                        <p class="text-danger">Redesign correlated subquery that depends on field person.company_id from super query</p>
                        <pre><code class="text-success">
<b>SELECT</b> p.id, p.first_name, p.last_name, c.name <b>AS</b> company_name
<b>FROM</b> person p left join company c on p.company_id = c.id
                        </code></pre>


                    <h3>
                        Replace <b>COUNT</b> with <b>EXISTS</b>
                    </h3>
                    <p>
                        Subqueries are slow but sometimes it's super-slow.
                        <b>COUNT</b> is very heavy function. But it's used to check if subquery returns at least 1 row.
                        The following request returns all companies that contains at least 1 employee.
                    </p>
                        <pre><code class="text-danger">
<b>SELECT</b> c.id, c.name
<b>FROM</b> company c
<b>WHERE</b> (<b>SELECT</b> COUNT(p.id) <b>FROM</b> person p <b>WHERE</b> p.company_id = c.id) > 0
                            </code></pre>

                        <p>
                        Replace <b>COUNT</b> in subquery with <b>EXISTS</b>
                        <pre><code class="text-success">
<b>SELECT</b> c.id, c.name
<b>FROM</b> company c
<b>WHERE</b> EXISTS(<b>SELECT</b> p.id <b>FROM</b> person p <b>WHERE</b> p.company_id = c.id)
                            </code></pre>

                        </p>




                    <h3>
                        Replace <b>MAX</b> / <b>MIN</b> with <b>EXISTS</b>
                    </h3>

                    <p>
                        Use aggregated functions in subqueries very carefully, much more carefully than in usual queries.

                        For example this query finds companies where the oldest employee was born before 1970 year.

                    </p>
                        <pre><code class="text-danger">
<b>SELECT</b> c.id, c.name
<b>FROM</b> company c
<b>WHERE</b> (<b>SELECT</b> MIN(p.birth_date <b>FROM</b> person p <b>WHERE</b> p.company_id = c.id) < '1970-01-01'
                        </code></pre>
                        <p>
                            Redesign this query and replace subselect which contains <b>MAX</b> / <b>MIN</b> with <b>EXISTS</b>.

                            This query does the same.
                            <pre><code class="text-success">
<b>SELECT</b> c.id, c.name
<b>FROM</b> company c
<b>WHERE EXISTS</b> (<b>SELECT</b> ID <b>FROM</b> person p <b>WHERE</b> p.birth_date < '1970-01-01')
                            </code></pre>
                        </p>





                    <h3>
                        Replace <b>OR</b> conditions with <b>IN</b> clause.
                    </h3>
                    <p>
                        <b>OR</b> makes queries slow.
                    </p>
                        <pre><code class="text-danger">
<b>SELECT</b> c.id, c.name
<b>FROM</b> company c
<b>WHERE</b> id = 1 <b>OR</b> id = 5 <b>OR</b> id = 12 <b>OR</b> id = 24
                        </code></pre>

                        <p>
                            Replace <b>OR</b> with <b>IN</b> clause
                        <pre><code class="text-success">
<b>SELECT</b> c.id, c.name
<b>FROM</b> company c
<b>WHERE</b> id <b>IN</b> (1, 5, 12, 24)
                            </code></pre>

                        </p>
                    <h3>
                        Redesign expression with indexed field.
                    </h3>
                        <pre><code>
<b>SELECT</b> p.id, p.first_name, p.last_name
<b>FROM</b> person p
<b>WHERE</b> extract(‘year’, p.birth_date) = 2000
                            </code></pre>
                        <p class="text-danger">
                        condition can be redesigned as
                        <pre><code class="text-success">
<b>SELECT</b> p.id, p.first_name, p.last_name
<b>FROM</b> person p
<b>WHERE</b> p.birth_date <b>BETWEEN</b> '2000-01-01 <b>AND</b> '2001-01-01'
                        </code></pre>
                        </p>
                    <h3>
                        <b>ILIKE</b> instead of <b>LOWER</b> or <b>UPPER</b>.
                    </h3>
                    <p>
                        Usual practice is to use UPPER / LOWER functions for case insensitive mode search.
                    </p>
                        <pre><code class="text-danger">
<b>SELECT</b> p.id, p.first_name, p.last_name
<b>FROM</b> person p
<b>WHERE</b> UPPER(p.first_name) = 'JOHN'
                            </code></pre>
                    <p>
                        The condition can be redesigned as
                    </p>
                        <pre><code class="text-success">
<b>SELECT</b> p.id, p.first_name, p.last_name
<b>FROM</b> person p
<b>WHERE</b> p.first_name ILIKE 'John'
                            </code></pre>
                    <h3>
                        Kick off <b>DISTINCT</b> and replace it with <b>EXISTS</b>.
                    </h3>
                    <p>
                        The following query needs to read all records from table person.
                    </p>
                        <pre><code class="text-danger">
<b>SELECT DISTINCT</b> p.company_id
<b>FROM</b> person p
                            </code></pre>
                    <p>
                        Query can be redesigned as
                    </p>
                        <pre><code class="text-success">
<b>SELECT</b> c.id
<b>FROM</b> company c
<b>WHERE EXISTS</b> (<b>SELECT</b> p.id <b>FROM</b> person p  <b>WHERE</b> p.company_id = c.id)
                            </code></pre>
            <p>

            </p>


                </ol>
            </p>
        </div>

    <footer class="bd-footer text-muted">
        <div class="container-fluid">
            <p>
                Copyright NFSQL 2018-2019  <a href="mailto:info@nfsql.com"> <i class="far fa-envelope"></i> info@nfsql.com</a>
            </p>
        </div>
    </footer>
    </body>
</html>