<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
        <meta name="yandex-verification" content="147f9d9fe95452a9" />
        <title>NFSql - Need For Speedy SQL</title>
        <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
        <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">

        <link href="https://fonts.googleapis.com/css?family=Montserrat:400,700" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="https://blackrockdigital.github.io/startbootstrap-freelancer/css/freelancer.min.css">
    </head>
    <body>

    <nav class="navbar navbar-expand-md navbar-dark bg-danger">
        <p class="text-danger">
            <a class="navbar-brand" href="#"><i class="fas fa-tachometer-alt"></i> NFSQL </a>
        </p>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>
    </nav>
<!--
        <nav class="navbar navbar-dark bd-navbar navbar-light sticky-top navbar-expand-md">
            <a class="navbar-brand" href="#">Navbar</a>
        </nav>
-->
    <div class="bg-primary text-white">
        <div class="container " style="padding-top:50px;">
            <div class="row ">
                <p class="col-md-3 text-center">
                    <img src="logo-icon.svg" style="max-width:150px;"><br/>
                    <img src="nfsqllogo.svg" style="max-width:150px;padding-top:20px;"><br/>
                    <!--
                    <img class="img-fluid" src="nfsql-logo.png" style="max-width:200px;">
                    -->
                </p>
                <div class="col-md-9">
                    <h3>
                        Need For Speedy SQL
                    </h3>
                    <h6>

                        We help companies to speed up databases, by optimizing SQL queries
                        that allows to decrease costs for clouds.
                    </h6>
                </div>
            </div>
        </div>
    </div>
        <div class="container" style="padding-top:50px;">
            <h3>
                Is your SQL DBs fast?
            </h3>
            <p>
                We insist that <b>every SQL database can work faster</b> on the same environment (CPU, RAM, HDD/SSD...). We know how to do that.
                We design tools that find slow queries in your DB, analyse it and find the best solutions for optimizing and speeding it up.
            </p>
            <!--
            <p>
                NFSQL analyser parses your queries, checks your database structure and generates
                reports that helps you to make your databases faster.
            </p>
            -->
            <h3>
                How it works?
            </h3>
            <p>
                We connect our service to your database and analyze your queries and statistics.
                Every day our analyser parses all queries that were executed and tries to
                find optimization for <b>every</b> query.
                After that it sends report to your DBA with evaluation of
                performance boost for every optimization.
            </p>
            <p>
                Let's assume your database executes 200 different queries every day.
                We can collect statistics and sort all queries by total time spent for all executions.
                <a href="https://en.wikipedia.org/wiki/Zipf%27s_law" title="Click to open Wikipedia article">Zipf empirical law</a> states that
                the first query takes 2 times more time than the second and 3 times more then the third query etc.
                So n-ranked query takes n-times less time then the first query. For example the first query takes 10% of all
                time spent by the server during 24 hours. The second query 5%, the third 3.33% etc.
            </p>
            <p class="text-center">
                <i>Zipf distribution for 200 queries</i><br>
                <a href="zipf-wide-labels.svg">
                    <img src="zipf-wide-labels.svg" class="img-fluid" alt="Zipf distribution for 200 queries">
                </a>
            </p>
            <p>
                So top-10 queries takes about 50% of all time
                (marked with <span style="background-color:#4285f4;display:inline-block;width:10px;height:10px;"></span> color)
                The rest 190 queries take also about 50%
                (marked with <span style="background-color:#db4437;display:inline-block;width:10px;height:10px;"></span> color).
            </p>
            <p>
                In order to speed up database usually DBA tries to optimize top-10 queries.
                It's good strategy but after 3-7 iterations it's not obviously how to optimize top-10 queries.
                It's time to optimize the rest 190 queries. They look fast but usually
                these queries can be 10x or even 100x times faster because nobody tries to optimize it.
                In the same time these queries takes CPU and IO resources and make top-10 queries slower.
                So optimizing last-190 queries makes top-10 queries faster.
            </p>
            <p>
                Usually most of these last-190 queries are easy to optimize.
                The only problem is the number.
                Some our clients have more than 1000 different queries and
                <span style="white-space:nowrap">last-990</span> queries takes about 70% of time.
                <b>Our goal is to analyze all queries automatically
                    to reveal problems and to propose solutions.</b>
            </p>

            <h3>
                Is it safe?
            </h3>
            <p>
                We connect to client's DB in read-only mode and we don't read your data.
                We just need your metadata information.
                So we use DB-accounts with minimum permission for our analyser to avoid any
                possibility of grabbing your data.
            </p>
            <p>
                Sometimes we need to understand the nature of your data to propose the best solutions.
                In this case we can install our application on you side so we don't have access to your DB.
            </p>

            <form action="analyse" method="get">
                <row>
                    <textarea rows="5" class="col-12" placeholder="Type your SQL query..." name="query"></textarea>
                </row>
                <row>
                    <p>
                        <input type="submit" class="btn btn-info" value="Optimize">
                    </p>
                </row>
            </form>
            <h3>
                Our Optimization
            </h3>
            <p>
                NFSQL Optimizer includes different approaches for optimizing SQL queries. Here some of them:
            </p>
            <h5>
                Index for foreign keys
            </h5>
                    <p>
                        Create index for field if it's used in join.
                        It's one of the simplest way to optimize your queries but
                        sometimes it's too difficult to check if all indexes are created.
                        So it's usual when required indexes are missed.
                        <pre><code>
<b>SELECT</b> p.id, p.first_name, p.last_name, c.name <b>AS</b> company_name
<b>FROM</b> person p
  <b>JOIN</b> company c <b>on</b> <span class="text-danger">p.company_id</span> = c.id
                        </code></pre>
                        <p class="text-danger">Check if index for field person.company_id is created</p>
                        <p class="text-success">NFSQL can check all indexes automatically and warn if it is missed. </p>
                    </p>

            <h5>
                Kick off of correlated subquery
            </h5>
                    <p>
                        Correlated query is a subquery which uses fields from super query as params.
                        So it can be executed many times (at least 1 query execution per one result row).
                    </p>
                        <pre><code>
<b>SELECT</b> p.id, p.first_name, p.last_name,
              (
                 <b>SELECT</b> c.name
                 <b>FROM</b> company c <b>where</b> c.id = <span class="text-danger">p.company_id</span>
              ) <b>AS</b> company_name
<b>FROM</b> person p
                        </code></pre>
                        <p class="text-danger">Redesign correlated subquery that depends on field person.company_id from super query</p>
                        <pre><code class="text-success">
<b>SELECT</b> p.id, p.first_name, p.last_name, c.name <b>AS</b> company_name
<b>FROM</b> person p left join company c on p.company_id = c.id
                        </code></pre>

<!--
                    <h3>
                        Replace <b>COUNT</b> with <b>EXISTS</b>
                    </h3>
                    <p>
                        Subqueries are slow but sometimes it's super-slow.
                        <b>COUNT</b> is very heavy function. But it's used to check if subquery returns at least 1 row.
                        The following request returns all companies that contains at least 1 employee.
                    </p>
                        <pre><code class="text-danger">
<b>SELECT</b> c.id, c.name
<b>FROM</b> company c
<b>WHERE</b> (<b>SELECT</b> COUNT(p.id) <b>FROM</b> person p <b>WHERE</b> p.company_id = c.id) > 0
                            </code></pre>

                        <p>
                        Replace <b>COUNT</b> in subquery with <b>EXISTS</b>
                        <pre><code class="text-success">
<b>SELECT</b> c.id, c.name
<b>FROM</b> company c
<b>WHERE</b> EXISTS(<b>SELECT</b> p.id <b>FROM</b> person p <b>WHERE</b> p.company_id = c.id)
                            </code></pre>

                        </p>
-->
                    <h5>
                        <b>COUNT</b> for huge tables
                    </h5>
                    <p>
                        COUNT takes a lot of time. Sometimes it's necessity in most cases user just want to know
                        if there are 100  records or 2 billions. Have you seen Google
                    </p>
                    <h5>
                        <b>COUNT</b> in conditions
                    </h5>
                    <p>
                        Subqueries are slow but sometimes it's super-slow.
                        <b>COUNT</b> finds all rows and takes a lot of time even if you need to check if it returns
                        only 10 rows. The following request returns all companies that contains 10 employees.
                    </p>
                    <pre><code class="text-danger">
<b>SELECT</b> c.id, c.name
<b>FROM</b> company c
<b>WHERE</b> (<b>SELECT</b> COUNT(p.id) <b>FROM</b> person p <b>WHERE</b> p.company_id = c.id) > 10
                            </code></pre>
                    <p>
                        It can be optimized with the following query.
                    </p>
            <pre><code class="text-success">
<b>SELECT</b> c.id, c.name
<b>FROM</b> company c
<b>WHERE</b> (<b>SELECT</b> COUNT(t.id) <b>FROM</b> (<b>SELECT</b> p.id <b>FROM</b> person p <b>WHERE</b> p.company_id = c.id <b>LIMIT</b> 11) <b>AS</b> t) > 10
                            </code></pre>
                    <p>
                        This query does not try to find all rows in table <i>person</i> and stops after matching 11 rows.
                    </p>



                    <h5>
                        Replace <b>MAX</b> / <b>MIN</b> with <b>EXISTS</b>
                    </h5>

                    <p>
                        Use aggregated functions in subqueries very carefully, much more carefully than in usual queries.

                        For example this query finds companies where the oldest employee was born before 1970 year.

                    </p>
                        <pre><code class="text-danger">
<b>SELECT</b> c.id, c.name
<b>FROM</b> company c
<b>WHERE</b> (<b>SELECT</b> MIN(p.birth_date <b>FROM</b> person p <b>WHERE</b> p.company_id = c.id) < '1970-01-01'
                        </code></pre>
                        <p>
                            Redesign this query and replace subselect which contains <b>MAX</b> / <b>MIN</b> with <b>EXISTS</b>.

                            This query does the same.
                            <pre><code class="text-success">
<b>SELECT</b> c.id, c.name
<b>FROM</b> company c
<b>WHERE EXISTS</b> (<b>SELECT</b> ID <b>FROM</b> person p <b>WHERE</b> p.birth_date < '1970-01-01')
                            </code></pre>
                        </p>





                    <h5>
                        Replace <b>OR</b> conditions with <b>IN</b> clause.
                    </h5>
                    <p>
                        <b>OR</b> makes queries slow.
                    </p>
                        <pre><code class="text-danger">
<b>SELECT</b> c.id, c.name
<b>FROM</b> company c
<b>WHERE</b> id = 1 <b>OR</b> id = 5 <b>OR</b> id = 12 <b>OR</b> id = 24
                        </code></pre>

                        <p>
                            Replace <b>OR</b> with <b>IN</b> clause
                        <pre><code class="text-success">
<b>SELECT</b> c.id, c.name
<b>FROM</b> company c
<b>WHERE</b> id <b>IN</b> (1, 5, 12, 24)
                            </code></pre>

                        </p>
                    <h5>
                        Redesign expression with indexed field.
                    </h5>
                        <pre><code>
<b>SELECT</b> p.id, p.first_name, p.last_name
<b>FROM</b> person p
<b>WHERE</b> extract(‘year’, p.birth_date) = 2000
                            </code></pre>
                        <p class="text-danger">
                        condition can be redesigned as
                        <pre><code class="text-success">
<b>SELECT</b> p.id, p.first_name, p.last_name
<b>FROM</b> person p
<b>WHERE</b> p.birth_date <b>BETWEEN</b> '2000-01-01 <b>AND</b> '2001-01-01'
                        </code></pre>
                        </p>
                    <h5>
                        <b>ILIKE</b> instead of <b>LOWER</b> or <b>UPPER</b>.
                    </h5>
                    <p>
                        Usual practice is to use UPPER / LOWER functions for case insensitive mode search.
                    </p>
                        <pre><code class="text-danger">
<b>SELECT</b> p.id, p.first_name, p.last_name
<b>FROM</b> person p
<b>WHERE</b> UPPER(p.first_name) = 'JOHN'
                            </code></pre>
                    <p>
                        The condition can be redesigned as
                    </p>
                        <pre><code class="text-success">
<b>SELECT</b> p.id, p.first_name, p.last_name
<b>FROM</b> person p
<b>WHERE</b> p.first_name ILIKE 'John'
                            </code></pre>
                    <h5>
                        Kick off <b>DISTINCT</b> and replace it with <b>EXISTS</b>.
                    </h5>
                    <p>
                        The following query needs to read all records from table person.
                    </p>
                        <pre><code class="text-danger">
<b>SELECT DISTINCT</b> p.company_id
<b>FROM</b> person p
                            </code></pre>
                    <p>
                        Query can be redesigned as
                    </p>
                        <pre><code class="text-success">
<b>SELECT</b> c.id
<b>FROM</b> company c
<b>WHERE EXISTS</b> (<b>SELECT</b> p.id <b>FROM</b> person p  <b>WHERE</b> p.company_id = c.id)
                            </code></pre>
            <p>

            </p>


                </ol>
            </p>
        </div>

    <footer class="bd-footer text-muted">
        <div class="container-fluid">
            <p>
                Copyright NFSQL 2018-2019  <a href="mailto:info@nfsql.com"> <i class="far fa-envelope"></i> info@nfsql.com</a>
            </p>
        </div>
    </footer>

    <!-- Yandex.Metrika counter -->
    <script type="text/javascript" >
   (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
   m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
   (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

   ym(52058586, "init", {
        id:52058586,
        clickmap:true,
        trackLinks:true,
        accurateTrackBounce:true,
        webvisor:true
   });
</script>
    <noscript><div><img src="https://mc.yandex.ru/watch/52058586" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
    <!-- /Yandex.Metrika counter -->

    </body>
</html>